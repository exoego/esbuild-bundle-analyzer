// src/index.ts
import { pathToFileURL } from "node:url";

// src/compare.ts
import fs2 from "node:fs";
import path from "node:path";

// node_modules/filesize/dist/filesize.esm.js
var ARRAY = "array";
var BIT = "bit";
var BITS = "bits";
var BYTE = "byte";
var BYTES = "bytes";
var EMPTY = "";
var EXPONENT = "exponent";
var FUNCTION = "function";
var IEC = "iec";
var INVALID_NUMBER = "Invalid number";
var INVALID_ROUND = "Invalid rounding method";
var JEDEC = "jedec";
var OBJECT = "object";
var PERIOD = ".";
var ROUND = "round";
var S = "s";
var SI = "si";
var SI_KBIT = "kbit";
var SI_KBYTE = "kB";
var SPACE = " ";
var STRING = "string";
var ZERO = "0";
var STRINGS = {
  symbol: {
    iec: {
      bits: ["bit", "Kibit", "Mibit", "Gibit", "Tibit", "Pibit", "Eibit", "Zibit", "Yibit"],
      bytes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
    },
    jedec: {
      bits: ["bit", "Kbit", "Mbit", "Gbit", "Tbit", "Pbit", "Ebit", "Zbit", "Ybit"],
      bytes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
    }
  },
  fullform: {
    iec: ["", "kibi", "mebi", "gibi", "tebi", "pebi", "exbi", "zebi", "yobi"],
    jedec: ["", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta"]
  }
};
function filesize(arg, {
  bits = false,
  pad = false,
  base = -1,
  round = 2,
  locale = EMPTY,
  localeOptions = {},
  separator = EMPTY,
  spacer = SPACE,
  symbols = {},
  standard = EMPTY,
  output = STRING,
  fullform = false,
  fullforms = [],
  exponent = -1,
  roundingMethod = ROUND,
  precision = 0
} = {}) {
  let e = exponent, num = Number(arg), result = [], val = 0, u = EMPTY;
  if (standard === SI) {
    base = 10;
    standard = JEDEC;
  } else if (standard === IEC || standard === JEDEC) {
    base = 2;
  } else if (base === 2) {
    standard = IEC;
  } else {
    base = 10;
    standard = JEDEC;
  }
  const ceil = base === 10 ? 1e3 : 1024, full = fullform === true, neg = num < 0, roundingFunc = Math[roundingMethod];
  if (typeof arg !== "bigint" && isNaN(arg)) {
    throw new TypeError(INVALID_NUMBER);
  }
  if (typeof roundingFunc !== FUNCTION) {
    throw new TypeError(INVALID_ROUND);
  }
  if (neg) {
    num = -num;
  }
  if (e === -1 || isNaN(e)) {
    e = Math.floor(Math.log(num) / Math.log(ceil));
    if (e < 0) {
      e = 0;
    }
  }
  if (e > 8) {
    if (precision > 0) {
      precision += 8 - e;
    }
    e = 8;
  }
  if (output === EXPONENT) {
    return e;
  }
  if (num === 0) {
    result[0] = 0;
    u = result[1] = STRINGS.symbol[standard][bits ? BITS : BYTES][e];
  } else {
    val = num / (base === 2 ? Math.pow(2, e * 10) : Math.pow(1e3, e));
    if (bits) {
      val = val * 8;
      if (val >= ceil && e < 8) {
        val = val / ceil;
        e++;
      }
    }
    const p = Math.pow(10, e > 0 ? round : 0);
    result[0] = roundingFunc(val * p) / p;
    if (result[0] === ceil && e < 8 && exponent === -1) {
      result[0] = 1;
      e++;
    }
    u = result[1] = base === 10 && e === 1 ? bits ? SI_KBIT : SI_KBYTE : STRINGS.symbol[standard][bits ? BITS : BYTES][e];
  }
  if (neg) {
    result[0] = -result[0];
  }
  if (precision > 0) {
    result[0] = result[0].toPrecision(precision);
  }
  result[1] = symbols[result[1]] || result[1];
  if (locale === true) {
    result[0] = result[0].toLocaleString();
  } else if (locale.length > 0) {
    result[0] = result[0].toLocaleString(locale, localeOptions);
  } else if (separator.length > 0) {
    result[0] = result[0].toString().replace(PERIOD, separator);
  }
  if (pad && Number.isInteger(result[0]) === false && round > 0) {
    const x = separator || PERIOD, tmp = result[0].toString().split(x), s = tmp[1] || EMPTY, l = s.length, n = round - l;
    result[0] = `${tmp[0]}${x}${s.padEnd(l + n, ZERO)}`;
  }
  if (full) {
    result[1] = fullforms[e] ? fullforms[e] : STRINGS.fullform[standard][e] + (bits ? BIT : BYTE) + (result[0] === 1 ? EMPTY : S);
  }
  return output === ARRAY ? result : output === OBJECT ? {
    value: result[0],
    symbol: result[1],
    exponent: e,
    unit: u
  } : result.join(spacer);
}

// src/utils.ts
import fs from "node:fs";
function loadJsonFile(path3) {
  return JSON.parse(fs.readFileSync(path3).toString("utf-8"));
}
function loadMetaFile(path3) {
  return loadJsonFile(path3);
}
function loadAnalysisJson(path3) {
  return loadJsonFile(path3);
}
function getInput(name) {
  const val = process.env[`INPUT_${name.toUpperCase()}`] || "";
  return val.trim();
}

// src/compare.ts
function compare(input) {
  let hasAnyChange = false;
  let output = `## \u{1F4E6} esbuild Bundle Analysis for ${input.name}

This analysis was generated by [esbuild-bundle-analyzer](https://github.com/exoego/esbuild-bundle-analyzer). \u{1F916}
`;
  const current = loadAnalysisJson(
    path.join(process.cwd(), input.analyzerDirectory, "bundle_analysis.json")
  );
  let base;
  try {
    base = loadAnalysisJson(
      path.join(
        process.cwd(),
        input.analyzerDirectory,
        "base/bundle/bundle_analysis.json"
      )
    );
  } catch (e) {
    base = {};
  }
  const allOutFiles = [
    .../* @__PURE__ */ new Set([...Object.keys(current), ...Object.keys(base)])
  ].sort();
  const comparison = allOutFiles.map((outfile) => {
    const currentStats = current[outfile];
    const baseStats = base[outfile];
    if (!currentStats) {
      hasAnyChange = true;
      return { ...baseStats, diff: -1, remark: "deleted" };
    }
    if (!baseStats) {
      hasAnyChange = true;
      return { ...currentStats, diff: -1, remark: "added" };
    }
    const diff = currentStats.bytes - baseStats.bytes;
    const increase = !!Math.sign(diff);
    if (diff !== 0) {
      hasAnyChange = true;
    }
    return {
      ...currentStats,
      diff,
      remark: increase ? "increased" : "decreased"
    };
  });
  if (hasAnyChange) {
    output += markdownTable(comparison, input.budgetPercentIncreaseRed);
    if (input.showDetails) {
      output += `
<details>
<summary>Details</summary>
<p>Next to the size is how much the size has increased or decreased compared with the base branch of this PR.</p>
<ul>
<li>\u203C\uFE0F: Size increased by ${input.budgetPercentIncreaseRed}% or more. Special attention should be given to this.</li>
<li>\u26A0\uFE0F: Size increased in acceptable range (lower than ${input.budgetPercentIncreaseRed}%).</li>
<li>\u2705: No change or even downsized.</li>
<li>\u{1F5D1}\uFE0F: The out file is deleted: not found in base branch.</li>
<li>\u{1F195}: The out file is newly found: will be added to base branch.</li>
</ul>
</details>
`;
    }
  } else {
    output += "This PR introduced no changes to the esbuild bundle! \u{1F64C}";
  }
  output += `<!-- __ESBUILD_BUNDLE_${input.name} -->`;
  if (!hasAnyChange && input.skipCommentIfEmpty) {
    output = "";
  }
  console.dir({
    input,
    hasAnyChange,
    output
  });
  console.log(output);
  fs2.mkdirSync(path.join(process.cwd(), input.analyzerDirectory), {
    recursive: true
  });
  fs2.writeFileSync(
    path.join(
      process.cwd(),
      input.analyzerDirectory,
      "bundle_analysis_comment.txt"
    ),
    output.trim()
  );
}
function filesize2(bytes) {
  return filesize(bytes, {
    spacer: "\xA0"
  });
}
function markdownTable(data, redThreshold) {
  const rows = data.map((d) => {
    return `${d.metafile} | ${d.outfile} | ${renderSize(d)} | ${renderNote(
      d,
      redThreshold
    )}
`;
  }).join("");
  return `
Meta File | Out File  | Size (raw) | Note 
----------|----------|-----------:|------
${rows}`;
}
function renderSize(d) {
  return filesize2(d.bytes);
}
function renderNote(d, redThreshold) {
  if (d.remark === "deleted") {
    return "\u{1F5D1}\uFE0F Deleted";
  }
  if (d.remark === "added") {
    return "\u{1F195} Added";
  }
  if (d.diff) {
    const percentChange = d.diff / d.bytes * 100;
    return `${renderStatusIndicator(percentChange, redThreshold)}${filesize2(
      d.diff
    )} (${sign(percentChange)}${percentChange.toFixed(1)}%)`;
  }
  return "\u2705  No change";
}
function sign(num) {
  return num < 0 ? "" : "+";
}
function renderStatusIndicator(percentChange, redThreshold) {
  let res;
  if (percentChange > 0 && percentChange < redThreshold) {
    res = "\u26A0\uFE0F";
  } else if (percentChange >= redThreshold) {
    res = "\u203C\uFE0F";
  } else {
    res = "\u2705 ";
  }
  return `${res} ${sign(percentChange)}`;
}

// src/report.ts
import fs3 from "node:fs";
import path2 from "node:path";
import process2 from "node:process";
function report(input) {
  const allPageSizes = getAllPageSizes(input);
  fs3.mkdirSync(path2.join(process2.cwd(), input.analyzerDirectory), {
    recursive: true
  });
  const resultJsonPath = path2.join(
    process2.cwd(),
    input.analyzerDirectory,
    "bundle_analysis.json"
  );
  fs3.writeFileSync(resultJsonPath, JSON.stringify(allPageSizes, null, 2));
  console.log(`Wrote ${resultJsonPath}`);
}
function getAllPageSizes(input) {
  const acc = {};
  return input.metafiles.reduce((acc2, metafile) => {
    const metaFilePath = path2.join(process2.cwd(), metafile);
    try {
      fs3.accessSync(metaFilePath, fs3.constants.R_OK);
    } catch (err) {
      console.error(
        `No meta file found at "${metaFilePath}" - a path to meta file may be wrong, or esbuild is not executed.`
      );
      process2.exit(1);
    }
    const metaFileJson = loadMetaFile(metaFilePath);
    Object.entries(metaFileJson.outputs).reduce((acc3, output) => {
      const [outfile, buildMeta] = output;
      acc3[`${metafile} -> ${outfile}`] = {
        bytes: buildMeta.bytes,
        metafile,
        outfile
      };
      return acc3;
    }, acc2);
    return acc2;
  }, acc);
}

// src/index.ts
function getOptions() {
  const rawMetafiles = getInput("metafiles");
  if (!rawMetafiles) {
    throw new Error("metafiles is not specified");
  }
  const name = getInput("name");
  if (!name) {
    throw new Error("name is not specified");
  }
  return {
    budgetPercentIncreaseRed: Number.parseInt(
      getInput("budget_percent_increase_red") || "20",
      10
    ),
    showDetails: ["true", "True", "TRUE"].includes(
      getInput("show_details") || "true"
    ),
    skipCommentIfEmpty: ["false", "False", "FALSE"].includes(
      getInput("skip_comment_if_empty") || "false"
    ),
    name,
    analyzerDirectory: getInput("analyze_directory") || ".analyzer",
    metafiles: rawMetafiles.split(",")
  };
}
function run(options = getOptions()) {
  report(options);
  compare(options);
}
if (import.meta.url === pathToFileURL(process.argv[1]).href) {
  run();
}
export {
  run
};
/*! Bundled license information:

filesize/dist/filesize.esm.js:
  (**
   * filesize
   *
   * @copyright 2024 Jason Mulligan <jason.mulligan@avoidwork.com>
   * @license BSD-3-Clause
   * @version 10.1.1
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL2luZGV4LnRzIiwgIi4uL3NyYy9jb21wYXJlLnRzIiwgIi4uL3NyYy91dGlscy50cyIsICIuLi9zcmMvcmVwb3J0LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBwYXRoVG9GaWxlVVJMIH0gZnJvbSBcIm5vZGU6dXJsXCI7XG5pbXBvcnQgeyBjb21wYXJlIH0gZnJvbSBcIi4vY29tcGFyZVwiO1xuaW1wb3J0IHsgcmVwb3J0IH0gZnJvbSBcIi4vcmVwb3J0XCI7XG5pbXBvcnQgdHlwZSB7IE9wdGlvbnMgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgZ2V0SW5wdXQgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5mdW5jdGlvbiBnZXRPcHRpb25zKCk6IE9wdGlvbnMge1xuXHRjb25zdCByYXdNZXRhZmlsZXMgPSBnZXRJbnB1dChcIm1ldGFmaWxlc1wiKTtcblx0aWYgKCFyYXdNZXRhZmlsZXMpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJtZXRhZmlsZXMgaXMgbm90IHNwZWNpZmllZFwiKTtcblx0fVxuXHRjb25zdCBuYW1lID0gZ2V0SW5wdXQoXCJuYW1lXCIpO1xuXHRpZiAoIW5hbWUpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIGlzIG5vdCBzcGVjaWZpZWRcIik7XG5cdH1cblx0cmV0dXJuIHtcblx0XHRidWRnZXRQZXJjZW50SW5jcmVhc2VSZWQ6IE51bWJlci5wYXJzZUludChcblx0XHRcdGdldElucHV0KFwiYnVkZ2V0X3BlcmNlbnRfaW5jcmVhc2VfcmVkXCIpIHx8IFwiMjBcIixcblx0XHRcdDEwLFxuXHRcdCksXG5cdFx0c2hvd0RldGFpbHM6IFtcInRydWVcIiwgXCJUcnVlXCIsIFwiVFJVRVwiXS5pbmNsdWRlcyhcblx0XHRcdGdldElucHV0KFwic2hvd19kZXRhaWxzXCIpIHx8IFwidHJ1ZVwiLFxuXHRcdCksXG5cdFx0c2tpcENvbW1lbnRJZkVtcHR5OiBbXCJmYWxzZVwiLCBcIkZhbHNlXCIsIFwiRkFMU0VcIl0uaW5jbHVkZXMoXG5cdFx0XHRnZXRJbnB1dChcInNraXBfY29tbWVudF9pZl9lbXB0eVwiKSB8fCBcImZhbHNlXCIsXG5cdFx0KSxcblx0XHRuYW1lLFxuXHRcdGFuYWx5emVyRGlyZWN0b3J5OiBnZXRJbnB1dChcImFuYWx5emVfZGlyZWN0b3J5XCIpIHx8IFwiLmFuYWx5emVyXCIsXG5cdFx0bWV0YWZpbGVzOiByYXdNZXRhZmlsZXMuc3BsaXQoXCIsXCIpLFxuXHR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVuKG9wdGlvbnM6IE9wdGlvbnMgPSBnZXRPcHRpb25zKCkpOiB2b2lkIHtcblx0cmVwb3J0KG9wdGlvbnMpO1xuXHRjb21wYXJlKG9wdGlvbnMpO1xufVxuXG5pZiAoaW1wb3J0Lm1ldGEudXJsID09PSBwYXRoVG9GaWxlVVJMKHByb2Nlc3MuYXJndlsxXSkuaHJlZikge1xuXHRydW4oKTtcbn1cbiIsICJpbXBvcnQgZnMgZnJvbSBcIm5vZGU6ZnNcIjtcbmltcG9ydCBwYXRoIGZyb20gXCJub2RlOnBhdGhcIjtcbmltcG9ydCB7IGZpbGVzaXplIGFzIG9yaWdpbmFsRmlsZXNpemUgfSBmcm9tIFwiZmlsZXNpemVcIjtcbmltcG9ydCB0eXBlIHsgQ29tcGFyZVJlc3VsdCwgT3B0aW9ucywgUmVwb3J0IH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IGxvYWRBbmFseXNpc0pzb24gfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZShpbnB1dDogT3B0aW9ucyk6IHZvaWQge1xuXHRsZXQgaGFzQW55Q2hhbmdlID0gZmFsc2U7XG5cdGxldCBvdXRwdXQgPSBgIyMgXHVEODNEXHVEQ0U2IGVzYnVpbGQgQnVuZGxlIEFuYWx5c2lzIGZvciAke2lucHV0Lm5hbWV9XG5cblRoaXMgYW5hbHlzaXMgd2FzIGdlbmVyYXRlZCBieSBbZXNidWlsZC1idW5kbGUtYW5hbHl6ZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9leG9lZ28vZXNidWlsZC1idW5kbGUtYW5hbHl6ZXIpLiBcdUQ4M0VcdUREMTZcbmA7XG5cblx0Y29uc3QgY3VycmVudCA9IGxvYWRBbmFseXNpc0pzb24oXG5cdFx0cGF0aC5qb2luKHByb2Nlc3MuY3dkKCksIGlucHV0LmFuYWx5emVyRGlyZWN0b3J5LCBcImJ1bmRsZV9hbmFseXNpcy5qc29uXCIpLFxuXHQpO1xuXHRsZXQgYmFzZTogUmVwb3J0O1xuXHR0cnkge1xuXHRcdGJhc2UgPSBsb2FkQW5hbHlzaXNKc29uKFxuXHRcdFx0cGF0aC5qb2luKFxuXHRcdFx0XHRwcm9jZXNzLmN3ZCgpLFxuXHRcdFx0XHRpbnB1dC5hbmFseXplckRpcmVjdG9yeSxcblx0XHRcdFx0XCJiYXNlL2J1bmRsZS9idW5kbGVfYW5hbHlzaXMuanNvblwiLFxuXHRcdFx0KSxcblx0XHQpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0YmFzZSA9IHt9O1xuXHR9XG5cblx0Y29uc3QgYWxsT3V0RmlsZXM6IHN0cmluZ1tdID0gW1xuXHRcdC4uLm5ldyBTZXQoWy4uLk9iamVjdC5rZXlzKGN1cnJlbnQpLCAuLi5PYmplY3Qua2V5cyhiYXNlKV0pLFxuXHRdLnNvcnQoKTtcblx0Y29uc3QgY29tcGFyaXNvbjogQXJyYXk8Q29tcGFyZVJlc3VsdD4gPSBhbGxPdXRGaWxlcy5tYXAoKG91dGZpbGUpID0+IHtcblx0XHRjb25zdCBjdXJyZW50U3RhdHMgPSBjdXJyZW50W291dGZpbGVdO1xuXHRcdGNvbnN0IGJhc2VTdGF0cyA9IGJhc2Vbb3V0ZmlsZV07XG5cblx0XHRpZiAoIWN1cnJlbnRTdGF0cykge1xuXHRcdFx0aGFzQW55Q2hhbmdlID0gdHJ1ZTtcblx0XHRcdC8vIGRlbGV0ZWQgb3V0IGZpbGVcblx0XHRcdHJldHVybiB7IC4uLmJhc2VTdGF0cywgZGlmZjogLTEsIHJlbWFyazogXCJkZWxldGVkXCIgfTtcblx0XHR9XG5cdFx0aWYgKCFiYXNlU3RhdHMpIHtcblx0XHRcdGhhc0FueUNoYW5nZSA9IHRydWU7XG5cdFx0XHQvLyBuZXcgb3V0IGZpbGVcblx0XHRcdHJldHVybiB7IC4uLmN1cnJlbnRTdGF0cywgZGlmZjogLTEsIHJlbWFyazogXCJhZGRlZFwiIH07XG5cdFx0fVxuXHRcdGNvbnN0IGRpZmYgPSBjdXJyZW50U3RhdHMuYnl0ZXMgLSBiYXNlU3RhdHMuYnl0ZXM7XG5cdFx0Y29uc3QgaW5jcmVhc2UgPSAhIU1hdGguc2lnbihkaWZmKTtcblx0XHRpZiAoZGlmZiAhPT0gMCkge1xuXHRcdFx0aGFzQW55Q2hhbmdlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdC4uLmN1cnJlbnRTdGF0cyxcblx0XHRcdGRpZmYsXG5cdFx0XHRyZW1hcms6IGluY3JlYXNlID8gXCJpbmNyZWFzZWRcIiA6IFwiZGVjcmVhc2VkXCIsXG5cdFx0fTtcblx0fSk7XG5cblx0aWYgKGhhc0FueUNoYW5nZSkge1xuXHRcdG91dHB1dCArPSBtYXJrZG93blRhYmxlKGNvbXBhcmlzb24sIGlucHV0LmJ1ZGdldFBlcmNlbnRJbmNyZWFzZVJlZCk7XG5cblx0XHRpZiAoaW5wdXQuc2hvd0RldGFpbHMpIHtcblx0XHRcdG91dHB1dCArPSBgXFxuPGRldGFpbHM+XG48c3VtbWFyeT5EZXRhaWxzPC9zdW1tYXJ5PlxuPHA+TmV4dCB0byB0aGUgc2l6ZSBpcyBob3cgbXVjaCB0aGUgc2l6ZSBoYXMgaW5jcmVhc2VkIG9yIGRlY3JlYXNlZCBjb21wYXJlZCB3aXRoIHRoZSBiYXNlIGJyYW5jaCBvZiB0aGlzIFBSLjwvcD5cbjx1bD5cbjxsaT5cdTIwM0NcdUZFMEY6IFNpemUgaW5jcmVhc2VkIGJ5ICR7aW5wdXQuYnVkZ2V0UGVyY2VudEluY3JlYXNlUmVkfSUgb3IgbW9yZS4gU3BlY2lhbCBhdHRlbnRpb24gc2hvdWxkIGJlIGdpdmVuIHRvIHRoaXMuPC9saT5cbjxsaT5cdTI2QTBcdUZFMEY6IFNpemUgaW5jcmVhc2VkIGluIGFjY2VwdGFibGUgcmFuZ2UgKGxvd2VyIHRoYW4gJHtpbnB1dC5idWRnZXRQZXJjZW50SW5jcmVhc2VSZWR9JSkuPC9saT5cbjxsaT5cdTI3MDU6IE5vIGNoYW5nZSBvciBldmVuIGRvd25zaXplZC48L2xpPlxuPGxpPlx1RDgzRFx1REREMVx1RkUwRjogVGhlIG91dCBmaWxlIGlzIGRlbGV0ZWQ6IG5vdCBmb3VuZCBpbiBiYXNlIGJyYW5jaC48L2xpPlxuPGxpPlx1RDgzQ1x1REQ5NTogVGhlIG91dCBmaWxlIGlzIG5ld2x5IGZvdW5kOiB3aWxsIGJlIGFkZGVkIHRvIGJhc2UgYnJhbmNoLjwvbGk+XG48L3VsPlxuPC9kZXRhaWxzPlxcbmA7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdG91dHB1dCArPSBcIlRoaXMgUFIgaW50cm9kdWNlZCBubyBjaGFuZ2VzIHRvIHRoZSBlc2J1aWxkIGJ1bmRsZSEgXHVEODNEXHVERTRDXCI7XG5cdH1cblxuXHQvLyB3ZSBhZGQgdGhpcyB0YWcgc28gdGhhdCBvdXIgYWN0aW9uIGNhbiBiZSBhYmxlIHRvIGVhc2lseSBhbmRcblx0Ly8gY29uc2lzdGVudGx5IGZpbmQgdGhlIHJpZ2h0IGNvbW1lbnQgdG8gZWRpdCBhcyBtb3JlIGNvbW1pdHMgYXJlIHB1c2hlZC5cblx0b3V0cHV0ICs9IGA8IS0tIF9fRVNCVUlMRF9CVU5ETEVfJHtpbnB1dC5uYW1lfSAtLT5gO1xuXG5cdC8vIGlmIGlnbm9yZUlmRW1wdHkgaXMgdHJ1ZSwgc2V0IG91dHB1dCB0byBhbiBlbXB0eSBzdHJpbmdcblx0aWYgKCFoYXNBbnlDaGFuZ2UgJiYgaW5wdXQuc2tpcENvbW1lbnRJZkVtcHR5KSB7XG5cdFx0b3V0cHV0ID0gXCJcIjtcblx0fVxuXHRjb25zb2xlLmRpcih7XG5cdFx0aW5wdXQsXG5cdFx0aGFzQW55Q2hhbmdlLFxuXHRcdG91dHB1dCxcblx0fSk7XG5cblx0Ly8gbG9nIHRoZSBvdXRwdXQsIG1vc3RseSBmb3IgdGVzdGluZyBhbmQgZGVidWdnaW5nLiB0aGlzIHdpbGwgc2hvdyB1cCBpbiB0aGVcblx0Ly8gZ2l0aHViIGFjdGlvbnMgY29uc29sZS5cblx0Y29uc29sZS5sb2cob3V0cHV0KTtcblxuXHQvLyBXcml0ZSB0aGUgb3V0cHV0IHRvIGEgZmlsZSB3aGljaCBpcyBsYXRlciByZWFkIGluXG5cdC8vIGFzIGNvbW1lbnQgY29udGVudHMgYnkgdGhlIGFjdGlvbnMgd29ya2Zsb3cuXG5cdGZzLm1rZGlyU3luYyhwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgaW5wdXQuYW5hbHl6ZXJEaXJlY3RvcnkpLCB7XG5cdFx0cmVjdXJzaXZlOiB0cnVlLFxuXHR9KTtcblx0ZnMud3JpdGVGaWxlU3luYyhcblx0XHRwYXRoLmpvaW4oXG5cdFx0XHRwcm9jZXNzLmN3ZCgpLFxuXHRcdFx0aW5wdXQuYW5hbHl6ZXJEaXJlY3RvcnksXG5cdFx0XHRcImJ1bmRsZV9hbmFseXNpc19jb21tZW50LnR4dFwiLFxuXHRcdCksXG5cdFx0b3V0cHV0LnRyaW0oKSxcblx0KTtcbn1cblxuZnVuY3Rpb24gZmlsZXNpemUoYnl0ZXM6IG51bWJlcik6IHN0cmluZyB7XG5cdHJldHVybiBvcmlnaW5hbEZpbGVzaXplKGJ5dGVzLCB7XG5cdFx0c3BhY2VyOiBcIlx1MDBBMFwiLFxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWFya2Rvd25UYWJsZShcblx0ZGF0YTogQXJyYXk8Q29tcGFyZVJlc3VsdD4sXG5cdHJlZFRocmVzaG9sZDogbnVtYmVyLFxuKTogc3RyaW5nIHtcblx0Y29uc3Qgcm93cyA9IGRhdGFcblx0XHQubWFwKChkKSA9PiB7XG5cdFx0XHRyZXR1cm4gYCR7ZC5tZXRhZmlsZX0gfCAke2Qub3V0ZmlsZX0gfCAke3JlbmRlclNpemUoZCl9IHwgJHtyZW5kZXJOb3RlKFxuXHRcdFx0XHRkLFxuXHRcdFx0XHRyZWRUaHJlc2hvbGQsXG5cdFx0XHQpfVxcbmA7XG5cdFx0fSlcblx0XHQuam9pbihcIlwiKTtcblxuXHRyZXR1cm4gYFxuTWV0YSBGaWxlIHwgT3V0IEZpbGUgIHwgU2l6ZSAocmF3KSB8IE5vdGUgXG4tLS0tLS0tLS0tfC0tLS0tLS0tLS18LS0tLS0tLS0tLS06fC0tLS0tLVxuJHtyb3dzfWA7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclNpemUoZDogQ29tcGFyZVJlc3VsdCk6IHN0cmluZyB7XG5cdHJldHVybiBmaWxlc2l6ZShkLmJ5dGVzKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTm90ZShkOiBDb21wYXJlUmVzdWx0LCByZWRUaHJlc2hvbGQ6IG51bWJlcik6IHN0cmluZyB7XG5cdGlmIChkLnJlbWFyayA9PT0gXCJkZWxldGVkXCIpIHtcblx0XHRyZXR1cm4gXCJcdUQ4M0RcdURERDFcdUZFMEYgRGVsZXRlZFwiO1xuXHR9XG5cdGlmIChkLnJlbWFyayA9PT0gXCJhZGRlZFwiKSB7XG5cdFx0cmV0dXJuIFwiXHVEODNDXHVERDk1IEFkZGVkXCI7XG5cdH1cblx0aWYgKGQuZGlmZikge1xuXHRcdGNvbnN0IHBlcmNlbnRDaGFuZ2UgPSAoZC5kaWZmIC8gZC5ieXRlcykgKiAxMDA7XG5cdFx0cmV0dXJuIGAke3JlbmRlclN0YXR1c0luZGljYXRvcihwZXJjZW50Q2hhbmdlLCByZWRUaHJlc2hvbGQpfSR7ZmlsZXNpemUoXG5cdFx0XHRkLmRpZmYsXG5cdFx0KX0gKCR7c2lnbihwZXJjZW50Q2hhbmdlKX0ke3BlcmNlbnRDaGFuZ2UudG9GaXhlZCgxKX0lKWA7XG5cdH1cblx0cmV0dXJuIFwiXHUyNzA1ICBObyBjaGFuZ2VcIjtcbn1cblxuZnVuY3Rpb24gc2lnbihudW06IG51bWJlcik6IHN0cmluZyB7XG5cdHJldHVybiBudW0gPCAwID8gXCJcIiA6IFwiK1wiO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTdGF0dXNJbmRpY2F0b3IoXG5cdHBlcmNlbnRDaGFuZ2U6IG51bWJlcixcblx0cmVkVGhyZXNob2xkOiBudW1iZXIsXG4pOiBzdHJpbmcge1xuXHRsZXQgcmVzOiBzdHJpbmc7XG5cdGlmIChwZXJjZW50Q2hhbmdlID4gMCAmJiBwZXJjZW50Q2hhbmdlIDwgcmVkVGhyZXNob2xkKSB7XG5cdFx0cmVzID0gXCJcdTI2QTBcdUZFMEZcIjtcblx0fSBlbHNlIGlmIChwZXJjZW50Q2hhbmdlID49IHJlZFRocmVzaG9sZCkge1xuXHRcdHJlcyA9IFwiXHUyMDNDXHVGRTBGXCI7XG5cdH0gZWxzZSB7XG5cdFx0cmVzID0gXCJcdTI3MDUgXCI7XG5cdH1cblx0cmV0dXJuIGAke3Jlc30gJHtzaWduKHBlcmNlbnRDaGFuZ2UpfWA7XG59XG4iLCAiaW1wb3J0IGZzIGZyb20gXCJub2RlOmZzXCI7XG5cbmltcG9ydCB0eXBlIHsgTWV0YWZpbGUgfSBmcm9tIFwiZXNidWlsZFwiO1xuaW1wb3J0IHR5cGUgeyBSZXBvcnQgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG5mdW5jdGlvbiBsb2FkSnNvbkZpbGUocGF0aDogc3RyaW5nKSB7XG5cdHJldHVybiBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhwYXRoKS50b1N0cmluZyhcInV0Zi04XCIpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRNZXRhRmlsZShwYXRoOiBzdHJpbmcpOiBNZXRhZmlsZSB7XG5cdHJldHVybiBsb2FkSnNvbkZpbGUocGF0aCkgYXMgTWV0YWZpbGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkQW5hbHlzaXNKc29uKHBhdGg6IHN0cmluZyk6IFJlcG9ydCB7XG5cdHJldHVybiBsb2FkSnNvbkZpbGUocGF0aCkgYXMgUmVwb3J0O1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYWN0aW9ucy90b29sa2l0L2Jsb2IvODFhNzNhYmE4YmVkZDUzMmY2ZWRkY2M0MWVkM2EwZmFkOGIxY2ZlYi9wYWNrYWdlcy9jb3JlL3NyYy9jb3JlLnRzI0wxMjZcbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnB1dChuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRjb25zdCB2YWwgPSBwcm9jZXNzLmVudltgSU5QVVRfJHtuYW1lLnRvVXBwZXJDYXNlKCl9YF0gfHwgXCJcIjtcblx0cmV0dXJuIHZhbC50cmltKCk7XG59XG4iLCAiaW1wb3J0IGZzIGZyb20gXCJub2RlOmZzXCI7XG5pbXBvcnQgcGF0aCBmcm9tIFwibm9kZTpwYXRoXCI7XG5pbXBvcnQgcHJvY2VzcyBmcm9tIFwibm9kZTpwcm9jZXNzXCI7XG5cbmltcG9ydCB0eXBlIHsgT3B0aW9ucywgUmVwb3J0IH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IGxvYWRNZXRhRmlsZSB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBvcnQoaW5wdXQ6IE9wdGlvbnMpOiB2b2lkIHtcblx0Y29uc3QgYWxsUGFnZVNpemVzID0gZ2V0QWxsUGFnZVNpemVzKGlucHV0KTtcblx0ZnMubWtkaXJTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCBpbnB1dC5hbmFseXplckRpcmVjdG9yeSksIHtcblx0XHRyZWN1cnNpdmU6IHRydWUsXG5cdH0pO1xuXHRjb25zdCByZXN1bHRKc29uUGF0aCA9IHBhdGguam9pbihcblx0XHRwcm9jZXNzLmN3ZCgpLFxuXHRcdGlucHV0LmFuYWx5emVyRGlyZWN0b3J5LFxuXHRcdFwiYnVuZGxlX2FuYWx5c2lzLmpzb25cIixcblx0KTtcblx0ZnMud3JpdGVGaWxlU3luYyhyZXN1bHRKc29uUGF0aCwgSlNPTi5zdHJpbmdpZnkoYWxsUGFnZVNpemVzLCBudWxsLCAyKSk7XG5cdGNvbnNvbGUubG9nKGBXcm90ZSAke3Jlc3VsdEpzb25QYXRofWApO1xufVxuXG5mdW5jdGlvbiBnZXRBbGxQYWdlU2l6ZXMoaW5wdXQ6IE9wdGlvbnMpOiBSZXBvcnQge1xuXHRjb25zdCBhY2M6IFJlcG9ydCA9IHt9O1xuXHRyZXR1cm4gaW5wdXQubWV0YWZpbGVzLnJlZHVjZSgoYWNjLCBtZXRhZmlsZSkgPT4ge1xuXHRcdGNvbnN0IG1ldGFGaWxlUGF0aCA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCBtZXRhZmlsZSk7XG5cdFx0dHJ5IHtcblx0XHRcdGZzLmFjY2Vzc1N5bmMobWV0YUZpbGVQYXRoLCBmcy5jb25zdGFudHMuUl9PSyk7XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFxuXHRcdFx0XHRgTm8gbWV0YSBmaWxlIGZvdW5kIGF0IFwiJHttZXRhRmlsZVBhdGh9XCIgLSBhIHBhdGggdG8gbWV0YSBmaWxlIG1heSBiZSB3cm9uZywgb3IgZXNidWlsZCBpcyBub3QgZXhlY3V0ZWQuYCxcblx0XHRcdCk7XG5cdFx0XHRwcm9jZXNzLmV4aXQoMSk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgbWV0YUZpbGVKc29uID0gbG9hZE1ldGFGaWxlKG1ldGFGaWxlUGF0aCk7XG5cdFx0T2JqZWN0LmVudHJpZXMobWV0YUZpbGVKc29uLm91dHB1dHMpLnJlZHVjZSgoYWNjLCBvdXRwdXQpID0+IHtcblx0XHRcdGNvbnN0IFtvdXRmaWxlLCBidWlsZE1ldGFdID0gb3V0cHV0O1xuXHRcdFx0YWNjW2Ake21ldGFmaWxlfSAtPiAke291dGZpbGV9YF0gPSB7XG5cdFx0XHRcdGJ5dGVzOiBidWlsZE1ldGEuYnl0ZXMsXG5cdFx0XHRcdG1ldGFmaWxlLFxuXHRcdFx0XHRvdXRmaWxlLFxuXHRcdFx0fTtcblx0XHRcdHJldHVybiBhY2M7XG5cdFx0fSwgYWNjKTtcblx0XHRyZXR1cm4gYWNjO1xuXHR9LCBhY2MpO1xufVxuIl0sCiAgIm1hcHBpbmdzIjogIjtBQUFBLFNBQVMscUJBQXFCOzs7QUNBOUIsT0FBT0EsU0FBUTtBQUNmLE9BQU8sVUFBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNEakIsT0FBTyxRQUFRO0FBS2YsU0FBUyxhQUFhQyxPQUFjO0FBQ25DLFNBQU8sS0FBSyxNQUFNLEdBQUcsYUFBYUEsS0FBSSxFQUFFLFNBQVMsT0FBTyxDQUFDO0FBQzFEO0FBRU8sU0FBUyxhQUFhQSxPQUF3QjtBQUNwRCxTQUFPLGFBQWFBLEtBQUk7QUFDekI7QUFFTyxTQUFTLGlCQUFpQkEsT0FBc0I7QUFDdEQsU0FBTyxhQUFhQSxL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QjtBQUFBLEVBQzdDO0FBQ0EsUUFBTSxPQUFPLFNBQVMsTUFBTTtBQUM1QixNQUFJLENBQUMsTUFBTTtBQUNWLFVBQU0sSUFBSSxNQUFNLHVCQUF1QjtBQUFBLEVBQ3hDO0FBQ0EsU0FBTztBQUFBLElBQ04sMEJBQTBCLE9BQU87QUFBQSxNQUNoQyxTQUFTLDZCQUE2QixLQUFLO0FBQUEsTUFDM0M7QUFBQSxJQUNEO0FBQUEsSUFDQSxhQUFhLENBQUMsUUFBUSxRQUFRLE1BQU0sRUFBRTtBQUFBLE1BQ3JDLFNBQVMsY0FBYyxLQUFLO0FBQUEsSUFDN0I7QUFBQSxJQUNBLG9CQUFvQixDQUFDLFNBQVMsU0FBUyxPQUFPLEVBQUU7QUFBQSxNQUMvQyxTQUFTLHVCQUF1QixLQUFLO0FBQUEsSUFDdEM7QUFBQSxJQUNBO0FBQUEsSUFDQSxtQkFBbUIsU0FBUyxtQkFBbUIsS0FBSztBQUFBLElBQ3BELFdBQVcsYUFBYSxNQUFNLEdBQUc7QUFBQSxFQUNsQztBQUNEO0FBRU8sU0FBUyxJQUFJLFVBQW1CLFdBQVcsR0FBUztBQUMxRCxTQUFPLE9BQU87QUFDZCxVQUFRLE9BQU87QUFDaEI7QUFFQSxJQUFJLFlBQVksUUFBUSxjQUFjLFFBQVEsS0FBSyxDQUFDLENBQUMsRUFBRSxNQUFNO0FBQzVELE1BQUk7QUFDTDsiLAogICJuYW1lcyI6IFsiZnMiLCAicGF0aCIsICJmcyIsICJmaWxlc2l6ZSIsICJmcyIsICJwYXRoIiwgInByb2Nlc3MiLCAiZnMiLCAicGF0aCIsICJwcm9jZXNzIiwgImFjYyJdCn0K
