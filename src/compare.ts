import fs from "node:fs";
import path from "node:path";
import type { CompareResult, Options, Report, TreeMapNode } from "./types";
import { loadAnalysisJson, loadMetaFile } from "./utils";

export function compare(input: Options): void {
	let hasAnyChange = false;
	let output = `## üì¶ esbuild Bundle Analysis for ${input.name}

This analysis was generated by [esbuild-bundle-analyzer](https://github.com/exoego/esbuild-bundle-analyzer). ü§ñ
`;

	const current = loadAnalysisJson(
		path.join(process.cwd(), input.analyzerDirectory, "bundle_analysis.json"),
	);
	const base = loadBaseAnalysisJson(input);

	const fileTree = buildFileTree(input);

	const allOutFiles: string[] = [
		...new Set([...Object.keys(current), ...Object.keys(base)]),
	].sort();

	const comparison: Array<CompareResult> = allOutFiles.map((outfile) => {
		const currentStats = current[outfile];
		const baseStats = base[outfile];

		if (!currentStats) {
			hasAnyChange = true;
			return { ...baseStats, diff: -1, remark: "deleted", tree: undefined };
		}

		const tree = fileTree.get(
			treeKey(currentStats.metafile, currentStats.outfile),
		);
		if (!baseStats) {
			hasAnyChange = true;
			return { ...currentStats, diff: -1, remark: "added", tree };
		}

		const diff = currentStats.bytes - baseStats.bytes;
		if (diff !== 0) {
			hasAnyChange = true;
		}
		return {
			...currentStats,
			diff,
			tree,
			remark: Math.sign(diff) ? "increased" : "decreased",
		};
	});

	if (hasAnyChange) {
		output += markdownTable(comparison, input.percentExtraAttention);
		output += fileSizeTable(comparison);
		output += detail(input);
	} else {
		output += "This PR introduced no changes to the esbuild bundle! üôå";
	}

	// we add this tag so that our action can be able to easily and
	// consistently find the right comment to edit as more commits are pushed.
	output += `<!-- __ESBUILD_BUNDLE_${input.name} -->`;

	writeComment(input, output);
}

function treeKey(metafile: string, outfile: string): string {
	return `${metafile} -> ${outfile}`;
}

// Write the output to a file which is later read in
// as comment contents by the actions workflow.
function writeComment(input: Options, output: string): void {
	fs.mkdirSync(path.join(process.cwd(), input.analyzerDirectory), {
		recursive: true,
	});
	fs.writeFileSync(
		path.join(
			process.cwd(),
			input.analyzerDirectory,
			"bundle_analysis_comment.txt",
		),
		output.trim(),
	);
}

function detail(input: Options): string {
	if (!input.showDetails) {
		return "";
	}
	return `\n<details>
<summary>Details</summary>
<p>Next to the size is how much the size has increased or decreased compared with the base branch of this PR.</p>
<ul>
<li>‚ÄºÔ∏è: Size increased by ${input.percentExtraAttention}% or more. Special attention should be given to this.</li>
<li>‚ö†Ô∏è: Size increased in acceptable range (lower than ${input.percentExtraAttention}%).</li>
<li>‚úÖ: No change or even downsized.</li>
<li>üóëÔ∏è: The out file is deleted: not found in base branch.</li>
<li>üÜï: The out file is newly found: will be added to base branch.</li>
</ul>
</details>\n`;
}

function loadBaseAnalysisJson(input: Options): Report {
	try {
		return loadAnalysisJson(
			path.join(
				process.cwd(),
				input.analyzerDirectory,
				"base/bundle/bundle_analysis.json",
			),
		);
	} catch (e) {
		// Empty if no base analysis found.
		// This is a case when analyzer is first set up or all artifacts are expired.
		return {};
	}
}

function buildFileTree(input: Options) {
	function buildRoot(
		input: Record<string, { bytesInOutput: number }>,
	): TreeMapNode {
		const root: TreeMapNode = { name: "", path: "", value: 0, children: [] };
		for (const [filePath, { bytesInOutput }] of Object.entries(input)) {
			const directories = filePath.split("/");
			buildNode(root, directories, bytesInOutput);
		}
		return root;
	}

	function buildNode(
		node: TreeMapNode,
		paths: Array<string>,
		value: number,
	): void {
		const first = paths.shift();
		if (first === undefined) {
			// leaf node (file)
			node.value += value;
			return;
		}
		let child = node.children.find((child) => child.name === first);
		if (!child) {
			child = {
				name: first,
				path: `${node.path}/${first}`.replace(/^\//, ""),
				value: 0,
				children: [],
			};
			node.children.push(child);
		}
		node.value += value;
		buildNode(child, paths, value);
	}

	const trees = new Map<string, TreeMapNode>();
	for (const metafile of input.metafiles) {
		const metafileJson = loadMetaFile(path.join(process.cwd(), metafile));
		for (const [outfile, buildMeta] of Object.entries(metafileJson.outputs)) {
			const tree = buildRoot(buildMeta.inputs);
			trees.set(treeKey(metafile, outfile), tree);

			fs.writeFileSync(
				path.join(process.cwd(), input.analyzerDirectory, "tree.json"),
				JSON.stringify(tree, null, 2),
			);
		}
	}
	return trees;
}

const spacer = "¬†";
function filesize(bytes: number): string {
	const sign = bytes < 0 ? "-" : "";
	const n = Math.abs(bytes);
	if (n < 1000) {
		return `${sign}${n}${spacer}B`;
	}
	if (n < 1000 * 1000) {
		return `${sign}${(n / 1000).toFixed(2)}${spacer}KB`;
	}
	if (n < 1000 * 1000 * 1000) {
		return `${sign}${(n / 1000 / 1000).toFixed(2)}${spacer}MB`;
	}
	if (n < 1000 * 1000 * 1000 * 1000) {
		return `${sign}${(n / 1000 / 1000 / 1000).toFixed(2)}${spacer}GB`;
	}
	throw new Error("Too large file size!! Are you sure?");
}

function markdownTable(
	data: Array<CompareResult>,
	redThreshold: number,
): string {
	const rows = data
		.map((d) => {
			return `${d.metafile} | ${d.outfile} | ${renderSize(d)} | ${renderNote(
				d,
				redThreshold,
			)}\n`;
		})
		.join("");

	return `
Meta File | Out File  | Size (raw) | Note 
----------|----------|-----------:|------
${rows}`;
}

/**
 * Find the top ten largest nodes in root tree.
 * Dig nodes until the depth of 3.
 */
function findLargeDirectories(root: TreeMapNode) {
	const nodes: TreeMapNode[] = [];
	const queue: Array<{ node: TreeMapNode; depth: number }> = [
		{ node: root, depth: 0 },
	];
	while (queue.length > 0) {
		const shift = queue.shift();
		if (!shift) {
			break;
		}
		const { node, depth } = shift;
		if (depth === 3) {
			nodes.push(node);
			continue;
		}
		if (node.children.length === 0) {
			nodes.push(node);
		} else {
			for (const item of node.children) {
				queue.push({ node: item, depth: depth + 1 });
			}
		}
	}
	const largeNodes = nodes.sort((a, b) => b.value - a.value).slice(0, 10);
	return {
		largeNodes,
		hasOther: nodes.length > 10,
	};
}

function fixedPercent(n: number, d: number): number {
	return Number.parseFloat(((n / d) * 100).toFixed(1));
}

function fileSizeTable(data: Array<CompareResult>): string {
	if (data.length === 0) {
		return "";
	}
	let output = "";
	output += "<details>\n";
	output += "<summary>Top ten largest paths</summary>\n";
	for (const d of data) {
		output += "\n";
		output += `## Meta file: ${d.metafile}, Out file: ${d.outfile}\n`;
		if (!d.tree) {
			output += "Ô∏èÔ∏èüóëÔ∏èDeleted\n";
			continue;
		}
		output += "| Path | Size |\n";
		output += "|------|-------|\n";
		const totalSize = d.tree.value;
		const { largeNodes, hasOther } = findLargeDirectories(d.tree);
		for (const { path, value } of largeNodes) {
			const percent = fixedPercent(value, totalSize);
			output += `| ${path} | ${renderBar(percent, value)} |\n`;
		}
		if (hasOther) {
			const otherSize = totalSize - largeNodes[0].value;
			const otherPercent = fixedPercent(otherSize, totalSize);
			output += `| (other) | ${renderBar(otherPercent, otherSize)} |\n`;
		}
	}
	output += "</details>\n";
	return output;
}

function renderBar(percent: number, bytes: number): string {
	const bar = progress(percent / 100);
	return `\${{\\color{Goldenrod}{ ${bar} }}}\$ ${percent.toFixed(
		1,
	)}%, ${filesize(bytes)}`;
}

// Block progression is 1/8 = 0.125
const blocks = ["", "‚ñè", "‚ñé", "‚ñç", "‚ñå", "‚ñã", "‚ñä", "‚ñâ", "‚ñà"];
const progression = 1 / (blocks.length - 1);
function progress(value: number, length = 25, vmin = 0.0, vmax = 1.0) {
	const v = value * length;
	const integerPart = Math.floor(v);
	const fractionalPart = v - integerPart;
	const i = Math.round(
		(progression * Math.floor(fractionalPart / progression)) / progression,
	);
	return "‚ñà".repeat(integerPart) + blocks[i];
}

function renderSize(d: CompareResult): string {
	return filesize(d.bytes);
}

function renderNote(d: CompareResult, redThreshold: number): string {
	if (d.remark === "deleted") {
		return "üóëÔ∏è Deleted";
	}
	if (d.remark === "added") {
		return "üÜï Added";
	}
	if (d.diff) {
		const percentChange = (d.diff / d.bytes) * 100;
		return `${renderStatusIndicator(percentChange, redThreshold)}${filesize(
			d.diff,
		)} (${sign(percentChange)}${percentChange.toFixed(1)}%)`;
	}
	return "‚úÖ  No change";
}

function sign(num: number): string {
	return num < 0 ? "" : "+";
}

function renderStatusIndicator(
	percentChange: number,
	redThreshold: number,
): string {
	let res: string;
	if (percentChange > 0 && percentChange < redThreshold) {
		res = "‚ö†Ô∏è";
	} else if (percentChange >= redThreshold) {
		res = "‚ÄºÔ∏è";
	} else {
		res = "‚úÖ ";
	}
	return `${res} ${sign(percentChange)}`;
}
